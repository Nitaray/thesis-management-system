type Query {
	allNamespaces: [Namespace!]
	allPods(namespace: String!): [Pod!]
	allDeployments(namespace: String!): [Deployment!]
	allStatefulSets(namespace: String!): [StatefulSet!]
	allServices(namespace: String!): [Service!]
	allConfigMaps(namespace: String!): [ConfigMap!]
	allSecrets(namespace: String!): [Secret!]
}

type Mutation {
	createNamespace(name: String!): Namespace
	createDeployment(namespace: String!, deployment: DeploymentInput!): Deployment
	createStatefulSet(namespace: String!, StatefulSet: StatefulSetInput!): StatefulSet
	createService(namespace: String!, service: ServiceInput!): Service
	createConfigMap(namespace: String!, configMap: ConfigMapInput!): ConfigMap
	createSecret(namespace: String!, secret: SecretInput!): Secret
}

type Namespace {
	name: String!
	deployments: [Deployment!]
	statefulSets: [StatefulSet!]
	pods: [Pod!]
	configMaps: [ConfigMap!]
	secrets: [Secret!]
	services: [Service!]
}

type Metadata {
	name: String!
	uid: String!
	namespace: Namespace!
}

input MetadataInput {
	name: String!
	uid: String
	namespace: String
}

type Deployment {
	meta: Metadata!
	replicas: Int!
	template: PodTemplate!
	yaml: String!
}

input DeploymentInput {
	name: String!
	replicas: Int!
	template: PodTemplateInput!
}

type StatefulSet {
	meta: Metadata!
	replicas: Int!
	serviceName: String!
	template: PodTemplate!
	yaml: String!
}

input StatefulSetInput {
	name: String!
	replicas: Int!
	serviceName: String!
	template: PodTemplateInput!
}

type Pod {
	meta: Metadata!
	hostIP: String!
	podIP: String!
	status: String!
}

type PodTemplate {
	meta: Metadata!
	containers: [Container!]!
}

input PodTemplateInput {
	meta: MetadataInput!
	containers: [ContainerInput!]!
}

type Container {
	name: String!
	image: String!
	resources: ResourceRequirements
	ports: [ContainerPort!]
	env: [EnvVar!]
}

input ContainerInput {
	name: String!
	image: String!
	resources: ResourceRequirementsInput
	ports: [ContainerPortInput!]
	env: [EnvVarInput!]
}

type ContainerPort {
	containerPort: Int!
	name: String
	protocol: PortProtocol 
}

input ContainerPortInput {
	containerPort: Int!
	name: String
	protocol: PortProtocol 
}

enum PortProtocol {
	UDP
	TCP
	SCTP
}

type EnvVar {
	name: String!
	value: String
	valueFrom: EnvVarSrc
}

input EnvVarInput {
	name: String!
	value: String
	valueFrom: EnvVarSrcInput
}

type EnvVarSrc {
	configMapKeyRef: KeyRef
	secretKeyRef: KeyRef
}

input EnvVarSrcInput {
	configMapKeyRef: KeyRefInput
	secretKeyRef: KeyRefInput
}

type KeyRef {
	name: String!
	key: String!
}

input KeyRefInput {
	name: String!
	key: String!
}

type ConfigMap {
	meta: Metadata!
	data: [MapValue!]
	yaml: String!
}

input ConfigMapInput {
	name: String!
	data: [MapValueInput!]
}

type MapValue {
	key: String!
	value: String!
}

input MapValueInput {
	key: String!
	value: String!
}

type Secret {
	meta: Metadata!
	type: String!
	data: [MapValue!]
	yaml: String!
}

input SecretInput {
	name: String!
	type: String!
	data: [MapValueInput!]
}

type Service {
	meta: Metadata!
	type: ServiceType!
	ports: [ServicePort!]
	yaml: String!
}

enum ServiceType {
	ExternalName,
	ClusterIP,
	NodePort,
	LoadBalancer,
}

input ServiceInput {
	name: String!
	type: ServiceType!
}

type ServicePort {
	name: String!
	protocol: String!
	port: String!
	targetPort: String!
	nodePort: String!
}

type PersistentVolume {
	meta: Metadata!
	accessMode: [VolumeAccessMode!]!
	volumeMode: String!
	capacity: String!
	reclaimPolicy: PersistentVolumeReclaimPolicy! 
	
}

enum PersistentVolumeReclaimPolicy {
	Retain,
	Delete
}

type PersistentVolumeClaim {
	meta: Metadata!
	volumeName: String!
	volumeMode: String!
	accessMode: [VolumeAccessMode!]!
	resources: ResourceRequirements
}

enum VolumeAccessMode {
	ReadWriteOnce,
	ReadOnlyMany,
	ReadWriteMany,
	ReadWriteOncePod,
}

type ResourceRequirements {
	limits: Resource
	requests: Resource
}

input ResourceRequirementsInput {
	limits: ResourceInput
	requests: ResourceInput
}

type Resource {
	cpu: String
	memory: String
}

input ResourceInput {
	cpu: String
	memory: String
}

type Thesis {
	title: String!
	studentName: String!
	supervisorName: String!
	summary: String
	report: String
	namespace: Namespace!
	user: User!
	tags: [ThesisTag!]
}

type ThesisTag {
	name: String!
	thesis: [Thesis!]
}

type User {
	name: String!
	username: String!
	thesis: [Thesis!]
	role: Role!
}

type Role {
	id: String!
	name: String!
	users: [User!]
}
